# 并查集

是一种树形结构。

**数据结构**：

《算法》提供的一种实现。

```java
//记录每个节点的根节点，刚开始都指向自己，即 [0,1,2,3,4,...]
//比如 parent[7]=0,表示索引为7的元素的根节点是索引为0的元素
private int[] parent;  // parent[i] = parent of i
//用于标记是否是根节点
//比如 rank[0]=1,表示第0个元素是根节点, 后面其他集合每合并到此集合上一次+1，比如rank[0]=3表示有其他集合合并到元素0为根的集合上两次
//两个集合合并时，rank小的要合并到rank大的集合上，只是将根元素指向rank大的集合的根元素
private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
//集合的个数，比如后面的案例，刚开始集合的个数和数组的个数相同，最后因为所有元素都连在了一起，所以集合的个数为1
private int count;     // number of components
```

**使用场景**：

1. **查找元素属于哪个集合** 沿着数组表示树形关系以上一直找到根(即：树中中元素为负数的位置)
2. **查看两个元素是否属于同一个集合** 沿着数组表示的树形关系往上一直找到树的根，如果根相同表明在同一个集合，否则不在
3. **将两个集合归并成一个集合** 将两个集合中的元素合并 将一个集合名称改成另一个集合的名称
4. **集合的个数** 遍历数组，数组中元素为负数的个数即为集合的个数。

**使用案例**：

+ 图的 Kruskal 最小生成树算法使用并查集实现添加边之前判断是否已经连通，之前两个集合已经连通的话再加边肯定会产生环。

  ```java
  // UF.java
  int[][] matrix = {
      {0, 7},
      {2, 3},
      {1, 7},
      {0, 2},
      {5, 7},
      {4, 5},
      {2, 6}
  };
  // parent: [0, 1, 2, 3, 4, 5, 6, 7], rank: [0, 0, 0, 0, 0, 0, 0, 0]
  // union 0 7: 刚开始都不是根节点，后面的会以前面的节点为根节点,parent[7]=0, rank[0]=1
  // parent: [0, 1, 2, 3, 4, 5, 6, 0], rank: [1, 0, 0, 0, 0, 0, 0, 0]
  // union 2 3: parent[3]=2, rank[2]=1
  // parent: [0, 1, 2, 2, 4, 5, 6, 0], rank: [1, 0, 1, 0, 0, 0, 0, 0]
  // union 1 7: 节点7以0为根节点，1的rank小于0也要以0为根节点，parent[1]=0, 不算合并，rank不变
  // parent: [0, 0, 2, 2, 4, 5, 6, 0], rank: [1, 0, 1, 0, 0, 0, 0, 0]
  // union 0 2: 此时有两个集合{0, 7， 1} {2， 3}，2合并到前面的集合，3还以2为根，通过parent[2]将两个集合合并成了一个集合
  // 查找3的根最终会经过parent[2]中转最终查到元素0
  // parent: [0, 0, 0, 2, 4, 5, 6, 0], rank: [2, 0, 1, 0, 0, 0, 0, 0]
  // parent: [0, 0, 0, 2, 4, 0, 6, 0], rank: [2, 0, 1, 0, 0, 0, 0, 0]
  // parent: [0, 0, 0, 2, 0, 0, 6, 0], rank: [2, 0, 1, 0, 0, 0, 0, 0]
  // parent: [0, 0, 0, 2, 0, 0, 0, 0], rank: [2, 0, 1, 0, 0, 0, 0, 0]
  ```

  