# 动态规划

动态规划是运筹学的一个分支。

**基本概念**：

+ 最优化原理

  将多阶段的过程问题求解转化为一系列单阶段问题求解，选择各阶段的决策使整个过程达到最优，这就是动态规划的基本思想。

+ 最优子结构

  最优策略序列的子策略序列总是最优的。

+ 重叠子结构

+ 动态规划求解的问题具有状态的无后效性

**动态规划的经典的案例**：

+ **最短路线**

+ **切杆问题**

+ **换零钱问题**

  > 不经常看，过一段时间就会忘，索性每次忘了重新写一次

  假设总金额是S, 有n种硬币, 面额 C1...Cn，设 F(S) 是总金额为S时硬币最少数量。

  先求状态转移方程，然后自底向上递推。

  这个问题状态转移方程还是比较容易推导的：F(S) = min(F(S-C1),F(S-C2),...,F(S-Cn)) + 1，子状态中有至少一个有解才满足这个等式。

  举个实例：假设 S=17, 有4种硬币，面额分别是 3,4,5,10。

  自下而上求解过程如下：

  ```
  F(0) = 0										//F(0)也是有解的，不需要硬币也是一种解
  F(1) 	min(F(1-3),F(1-4),F(1-5),F(1-10)) 		//因为所有子状态金额全部是负数，所以无解，所以F(1)无解，无解在代码中就会直接跳过
  F(2) 											//同理无解跳过
  F(3) = min(F(3-3),F(3-4),F(3-5),F(3-10)) + 1
  	 = min(F(0)) + 1							//存在一个子状态有解
       = 1     									//即F(3)最优解是1
  F(4) = 1     									//同F(3)的求解方式, 这里省略过程
  F(5) = 1										//同F(3)的求解方式, 这里省略过程
  F(6) = min(F(6-3),F(6-4),F(6-5),F(6-10)) + 1
  	 = min(F(3)) + 1 							//过滤掉无解的子状态
  	 = 1 + 1 
  	 = 2
  ...
  F(17)=...
  ```

  后面只需要用代码描述这个过程。

  ```java
  //这里为了方便回顾，注释写的详细点
  public int coinChange(int[] coins, int amount) {
      int[] dp = new int[amount+1];   //存储F(i)的最优解, 从0到amount实际是amount+1个元素
      Arrays.fill(dp, -1);        //暂且用-1表示无解
      dp[0] = 0;                      //这个解是约定俗成的
  
      int min;
      for (int i = 1; i <= amount ; i++) {  //这里描述从F(1)到F(amount)的过程
          //描述F(i) = min(F(i-C1),F(i-C2),...,F(i-Cn)) + 1，即依次判断所有子状态是否有最优解，选择最小值然后加1作为F(i)的最优解
          min = -1;
          for (int coin : coins) {
              if (i - coin < 0) {     //负值无解
                  continue;
              }
              int candidate = dp[i - coin];    //F(i-Cj)
              if (candidate == -1) {  //此子状态没有最优解直接跳过
                  continue;
              }
              min = min == -1 ? candidate : Math.min(min, candidate);
          }
          if (min == -1) {
              continue;               //F(i)没有最优解直接跳过
          }
          dp[i] = min + 1;            //有最优解+1保存
      }
  
      return dp[amount];
  }
  ```

+ **0-1背包问题**

  动态规划解决0-1背包问题举例：

  有5个物品，重量分别是{2,2,6,5,4}, 价值分别是{6,3,5,4,6}，背包容量为10，求装入背包的物品和获得的最大价值。

  设xi表示物品i装入背包，xi=0表示物品i没有被装入背包；

  约束条件：
  $$
  \left\{\begin{array}{c}\sum_{i=1}^n w_i x_i\leq C\\ x_i\in\{0,1\}\quad(1\leq i\leq n)\\ 
  \end{array}\right.
  $$
  即装入背包的物品总重量要不大于背包容量；

  目标函数：
  $$
  \max\quad\sum_{i=1}^n v_i x_i
  $$
  即放入背包的物品总价值。

  问题归结为寻找一个满足约条件式1,并使目标函数式2达到最大的解向量X={x1,x2,...,xn}。

  设V(i, j) 表示在前i(1<=i<=n)个物品中能够装入容量为（1<=j<=C）的背包中的物品最大价值，则可推导出动态规划函数：
  $$
  V(i,j)=\begin{cases}V(i-1,j)&j<w_i\\ \max\{V(i-1,j),&V(i-1,j-w_i)+v_i\}&j>=w_i\end{cases}
  $$

  $$
  V(i,0)=V(0,j)=0
  $$

  从自低向上法处理(这里选择从选择物品数最少占用容量最少开始)：

  |           | i\价值\j | 0    | 1    | 2    | 3    | 4    | 5    | 6     | 7     | 8     | 9    | 10   |
  | --------- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ----- | ---- | ---- |
  |           | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0    | 0    |
  | w1=2,v1=6 | 1        | 0    | 0    | 6<1> | 6    | 6    | 6    | 6     | 6     | 6     | 6    | 6    |
  | w2=2,v2=3 | 2        | 0    | 0    | 6<2> | 6    | 9<3> | 9    | 9     | 9     | 9     | 9    | 9    |
  | w3=6,v3=5 | 3        | 0    | 0    | 6    | 6    | 9    | 9    | 9     | 9     | 11    | 11   | 14   |
  | w4=5,v4=4 | 4        | 0    | 0    | 6    | 6    | 9    | 9    | 9     | 10<5> | 11    | 13   | 14   |
  | w5=4,v5=6 | 5        | 0    | 0    | 6    | 6    | 9    | 9    | 12<4> | 12    | 15<6> | 15   | 15   |

  通过函数4, (i=0,j) 和 (i, j=0) 的行和列都是0；

  通过函数3的j<wi的情况推出：V(i=1,j=1) = V(0,1) = 0, 进而推出 V(i,j=1)那列全为0；

  <1>: i=1,j=2, 满足j>=w1, V(1,2) = max{V(0,2), V{0, 2-w1} + v1} = 6

  <2>: i=2,j=2, 满足j>=w2, V(2,2) = max{V(1,2), V{1, 2-w2} + v2} = max{6, V{1,0} + 3} = max{6,3} = 6

  <3>:  i=2,j=4, 满足j>=w2, V(2,4) = max{V(1,4), V{1, 4-w2} + v2} = max{6, V{1,2} + 3} = max{6,9} = 9

  <4>:  i=5,j=6, 满足j>=w5, V(5,6) = max{V(4,6), V{4, 6-w5} + v5} = max{9, V{4,2} + 6} = max{9,12} = 12

  <5>:  i=4,j=7, 满足j>=w4, V(4,7) = max{V(3,7), V{3, 7-w4} + v4} = max{3, V{3,2} + 4} = max{6,10} = 10

  <6>:  i=5,j=8, 满足j>=w5, V(5,8) = max{V(4,8), V{4, 8-w5} + v5} = max{11, V{4,4} + 6} = max{11,15} = 15

  代码实现：

  ```java
  //二维数组，自底向上两层遍历，每个元素代入公式3,4进行求解最优子结构
  
  ```

  > 难点是抽象出约束条件、目标函数，然后准确推导出动态规划函数，有了函数其他就很简单了。

+ 最长公共子序列问题（LCS）

**动态规划实现**：

+ 递归法

+ 带备忘的自顶向下法

  优化的递归法

+ 自低向上法

  从更小的子问题开始求解，当求解某个子问题时，它所依赖的更小的子问题都已求解完毕，每个子问题只需要求解一次。

**求解步骤**：

1）找出最优解的性质，并刻画其结构特征；

2）递归的定义最优值；

3）以自底向上的方式计算出最优值；

4）根据计算最优值时记录的信息，构造最优解。

