# 分布式一致性算法

- [Raft](https://raft.github.io/)
- Paxos
- ZAB (Zookeeper原子广播)
- BASE
- Gossip



## [Raft](https://raft.github.io/)

**论文中文翻译**：https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md。

**演示网站**：https://thesecretlivesofdata.com/raft/，比官方的更容易理解，但是也有些小问题。

**Raft协议实现**（Java，most star）：

官网列举了很多使用Raft协议的开源项目，但是大多并不是纯粹的Raft算法实现，这里了列举一些纯粹的算法实现项目。

+ [raft-java](https://github.com/wenweihu86/raft-java)

  Raft协议学习项目，适合学习使用。

+ [Apache Ratis](https://github.com/apache/ratis)

> 结合论文、源码实现、演示理解Raft。
>
> 官网演示了一个包含5个节点的分布式日志存储服务器。

### 工作原理

#### 基本概念实现啊

+ 节点状态 State

  + Follower (节点初始状态)

  + Candidate

    候选人，可以参与Leader选举。

  + Leader

    经过选举后的主节点。

+ 任期 Term

+ 日志复制 Log Replication

  Leader选举出来后，如果有数据修改请求都是先发给Leader节点，然后Leader需要通过日志复制将修改数据同步到其他节点。发送的消息称为“Append Entry”。

#### 工作流程

> 语言描述其实很容易落下很多细节，最好还是从Raft源码实现理解。

**主要流程**（简略）：

1. 系统初始化，各个节点刚初始化后都是Follwer状态；
2. 各个节点初始化后如果没有接收到Leader的消息就会认为当前没有Leader节点，会向配置表中的其他节点发送拉票信息，举荐自己为Leader;
3. 其他节点收到信息会投票，如果发起者收到多数的投票支持，就会称为Leader节点，所有会修改系统的请求都会经过Leader;
4. 每一条修改请求都会添加到Leader节点的记录中；但是还未提交，不会真地去修改数据；
5. 要提交修改数据，需要先将修改数据复制到其他所有Follower节点，并等待其他节点响应，当有多数节点响应已收到修改数据，主节点才会提交修改，将主节点的数据修改为目标值；
6. Leader提交修改后，需要向所有Follower节点同步提交要求，Follower节点收到同步提交请求后，保存自身的修改数据，从而达成一致；这个过程也称为“日志复制 Log Replication”；

> 实际的情况往往比上面说的复杂的多，可能多个节点同时发起拉票，可能存在部分节点通信故障等等。

**Leader选举**（详细）：

系统多个节点启动有先有后，有快有慢，可能出现第一个节点启动后发送拉票信息，其他节点还没完成启动无法响应等等情况；

Raft协议为了处理一些特殊情况，设置了两个超时时间：

+ 选举超时 Election Timeout

  选举超时是Follower在修改为Candidate状态之前等待的时间，选举超时随机设置为150毫秒到300毫秒之间。

+ 心跳超时 Heartbeat Timeout

  节点当选Leader后每个心跳周期内向其他节点发送一次自己当选Leader的消息，维持自己在其他节点的Leader地位。

这里再详细过一遍上面步骤1-3：

1. 系统初始化，各个节点刚初始化后都是Follwer状态, Term=0；然后随机等待 150ms - 300ms; 

2. 系统中总有一个节点最先选举超时，然后修改自己的状态为Candidate，Term=Term+1=1, 先给自己投1票，然后向节点配置表中的其他节点发起拉票请求；

   此时，其他节点的状态可能是：尚未启动、Follower状态、刚切换Candidate状态（虽然慢了一点点仍会向其他节点发起拉票请求，网络环境是复杂的，还不一定谁先获得多次支持呢）；

3. 尚未启动的节点无响应；已经启动的Follower节点接收到第一个拉票请求，检查请求中Term > 本地Term，Term=Term+1=1，投赞成票并重置选举超时时间，如果节点在本轮选举中后续又接收到另一个节点拉票请求也不再投票；Candidate节点收到其他Candidate节点拉票请求，投反对票。

   > 注意：每轮选举（Term）每个节点只能投一次赞成票。

4. Candidate节点统计本轮选举得票数，可能由于多数节点还未启动完成等原因，直到超时也没有收到多数支持票；Term=Term+1，重置超时时间，再次向其他节点发起拉票请求；

   > 注意：可能Candidate选举超时重新发起拉票前，Follower先选举超时了，这是Follower会变成Candidate，向其他节点发起拉票请求。

5. 直到有一个节点收到多数支持票，向其他节点发布自己当选Leader的消息，按心跳超时指定的时间间隔发送；其他节点记录Leader节点信息；

   > 疑问：节点收到多数支持票，向所有其他节点发送自己当选Leader的消息，还是只向自己的支持者Follwer发送消息？
   >
   > 注意：当选后每个心跳周期内发送一次，维持自己在其他节点的Leader地位。

6. 一旦心跳超时，Follower 会知道 Leader 异常，会重新变为 Candidate 状态，参与下轮选举。

   > 疑问：
   >
   > 异常的Leader会从节点列表中除名么？

**日志复制 Log Replication**：

对应主要流程的步骤：4-6。

**网络分区（脑裂）恢复后仍可保持一致性的原理**：

脑裂后，多数节点所在分区如果有Leader会正常继续运行，没有Leader会重新选举一个Leader然后继续运行；少数节点分区所有更新操作都无法完成；分区再次连接后（比如修复了网络故障），如果少数节点分区有Leader, Leader会从发送给其他节点的心跳响应中看到更高的任期Term，从而选择退位，然后回滚未提交的修改，并从新Leader节点同步最新数据。

#### 源码实现流程图

##### [raft-java](https://github.com/wenweihu86/raft-java)





