# B+树

由于B树非叶子节点也是会存数据的（value），磁盘读取是按”块“读取的，一”块“磁盘空间，如果既存key, 又存value, 势必会导致这块空间能存的key更少，也即B树的阶更小，存储同样数据量的数据树的深度更大，也即磁盘IO更多，性能更差。

那能不能非叶子节点只存key不存value，value全存到叶子节点，那一”块“磁盘空间就能存更多的key，存储同样数量的数据，树的深度更小，磁盘IO更少，性能更好。

B+树相对B树核心区别：非叶子节点不存数据，省出来的空间全存key。

> B树一个节点如果用多”块“磁盘空间存储呢？多块磁盘空间一样是需要磁盘IO的，虽然是顺序读写性能相对随机读写好一些，但依然有性能损耗。

**B+树定义**（或结构特征）：

第一种定义：

- 每个节点最多可以有 m 个元素；
- 除了根节点外，每个节点最少有 (m/2) 个元素；
- 如果根节点不是叶节点，那么它最少有 2 个孩子节点；
- 所有的叶子节点都在同一层；
- 一个有 k 个孩子节点的非叶子节点有 k 个元素，按升序排列；
- 某个元素的左子树中的元素都比它小，右子树的元素都大于或等于它；
- 非叶子节点只存放关键字和指向下一个孩子节点的索引，记录只存放在叶子节点中；
- 相邻的叶子节点之间用指针相连。

第二种定义：

+ B+树的非叶子节点不保存具体的数据，而只保存关键字的索引，而所有的数据最终都会保存到叶子节点。

+ B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针（即叶子节点构成链表）。

+ 非叶子节点的子节点数=关键字(key)数。

**B+树 vs B树**：

+ B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。
+ B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
+ B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

+ B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字和数据，所以在查询这种数据检索的时候会要比B+树快。

**B*树**：

B+树的增强版，在非根、非叶子节点添加了指向兄弟节点的指针。



## B+ 实现原理

**一种实现的数据结构**：

```java
ublic class BPlusTree<K extends Comparable<K>, V> {

    // 根节点
    protected BPlusNode<K, V> root;
    // 阶数，M值
    protected int order;
    // 叶子节点的链表头
    protected Node<K, V> head;
    // 树高
    protected int height = 0;
    ...
}

public class Node<K extends Comparable<K>, V> {

    // 是否为叶子节点
    protected boolean isLeaf;
    // 是否为根节点
    protected boolean isRoot;
    // 父节点
    protected Node<K, V> parent;
    // 叶节点的前节点
    protected Node<K, V> previous;
    // 叶节点的后节点
    protected Node<K, V> next;
    // 节点的关键字列表
    protected List<Entry<K, V>> entries;
    // 子节点列表
    protected List<Node<K, V>> children;
}
```

