## 哈希表

#### 哈希表简介

+ 定义  
哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。
也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。
这个映射函数称做散列函数，存放记录的数组称做散列表。

+ 基本概念  
若关键字为 k，则其值存放在 f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。  

对不同的关键字可能得到同一散列地址，即 k1 != k2，而 f(k1) == f(k2)，这种现象称为冲突（英语：Collision）。
具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，
并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。  

若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），
这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。

#### 哈希表数据结构中的问题点

+ 设计哈希函数  
    键的类型可能是各种各样的，最后都要通过哈希函数转化成数组索引，然后通过索引迅速获取对应的值。
    
    键为小范围正整数可以直接作为索引；   
    键为小范围负整数可以先偏移再作为索引；  
    对于大整数（键为长度比较长的数）可以取模作为索引，为了使得数据分布均匀通常选择取摸一个素数，
    素数选择与范围对应关系参考： https://planetmath.org/goodhashtableprimes；  
    键为浮点型，将浮点数的二进制表示当做整形数处理；  
    键为字符串，也可以通过某些方式转为整形处理，JDK中就使用了很多hash算法。
    
    JDK中Object类就提供了计算哈希码的方法 hashCode()，实际项目中可以在此基础上做额外处理然后与存储值的数组的索引对应起来；  
    当然也可以自行设计hashCode(), 只要遵循下面三个设计原则即可。
    
    哈希函数设计原则：  
    1）均匀性：“键”通过哈希函数得到的“索引”分布越均匀越好；    
    2）一致性：如果a==b, 则hash(a) == hash(b)；  
    3）高效性：计算高效简便。  

    补充：更多原理上的解释参考《数论》。
     
+ 解决键和索引的哈希冲突  
    链地址法（Seperate Chaining）, 对于不同的键求hash值如果hash值相同，则将他们的值存储为一个链表，然后再放入数组中。
    这种做法在容器类源码分析过程中遇到了很多。  
    除了将冲突数据存储为一个链表，还可以存储为其他的数据类型如TreeMap, 从链表转为TreeMap可以极大的提升对冲突数据的读取效率。  
  
    HashMap当hash冲突到达一定程度后，就是树（红黑树）的数组，而Java8之前始终是一个链表；
    HashSet是TreeSet的数组。  

#### 哈希表的实现
具体可以参考JDK java.util.HashTable的实现。

包含如下几点：  
1）数据结构设计（数组+树）
2）hashCode()方法设计
3）动态空间处理 resize() 与 hashCode索引重新映射
4）常用方法实现（增删改查）
    
    