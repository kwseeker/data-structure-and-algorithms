## 树
参考：    
《算法导论》  
《数据结构Java版》  
维基百科对计算机科学树的总结  https://en.wikipedia.org/wiki/Template:CS_trees  
                          https://zh.wikipedia.org/zh-hans/Template:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%A0%91  

相关术语：  
节点层次（根节点层次为1）  
树的深度（高度）  
节点的度（节点分支个数）  
无序树与有序树（树中任意一个结点的各子树按从左到右是有序的，称为有序树，否则称为无序树。）  

注意：树是图的一种。  

疑问：线段树和区间树到底是不是同一种数据结构？
看英文的资料说 segment tree, interval tree, range tree是三种不同的数据结构，但是中文网上的博客翻译的乱七八招的。

#### 基本分类
从网上抄的一个分类表，这个分类有问题，后面全部理清重新分类。

+ 二叉树（每个节点最多只有两个子节点） 
    - 完全二叉树（若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都必须达到最大个数，第h 层所有的结点都连续集中在最左边）
        * 满二叉树（一棵深度为k，且有2^k-1个节点的树是满二叉树）
    - 二叉排序树[二分搜索树] （左子树所有节点均小于根节点的值，右子树所有节点均大于根节点的值，左右子树也分别为二叉排序树）
    - 平衡二叉树（它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。）
        * 线段树[Segment Tree]（是一种平衡二叉搜索树）
        * AVL树
        * 红黑树（自平衡的二叉排序树）
            + 区间树 
    - 堆（一种完全二叉树，某个节点的值总是不大于或不小于其孩子节点的值，堆的每个子树也是堆）
+ 霍夫曼树
+ B树
    - B树（B-树）
    - B+树
    - B*树
+ 键树
+ 字典树[Trie]
+ 后缀树
+ 败者数与胜者树

#### 二叉排序树/二分搜索树（BST, Binary Search Tree）

根据遍历时根节点的顺序分为前序遍历、中序遍历、后序遍历；  
前序遍历（根节点->左子节点->右子节点）  
中序遍历（左子节点->根子节点->右子节点）  
后序遍历（左子节点->右子节点->根子节点）  
层序遍历（又成为广度遍历，从顶向下一层一层的遍历，使用队列实现）

#### AVL树


#### 红黑树


#### 线段树

TODO: 不知下面的定义是否准确，网上的文章都是各种误导，各种和区间树的混为一谈。

线段树（存储区间） https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9_(%E5%84%B2%E5%AD%98%E5%8D%80%E9%96%93)

线段树的定义：  
线段树是一种平衡二叉排序树，  
对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。  
因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。  

应用场景： 某些只关注区间的场景；  
如：实际应用中经常遇到区间查询场景，如电商查询某类产品在某个价格区间的产品列表；
如：区间染色的问题（对区间某个子区间进行染色，经过m次操作之后，可以在[i, j]区间看到多少种颜色？）。

上面的问题可以也可以使用数组解决，但是线段树的算法复杂度更低。

操作 | 数组实现 | 线段树实现 
---|---|--- 
更新 | O(n) | O(logn) 
查询 | O(n) | O(logn)

#### B树
+ B树定义
    B树和B+树是为了处理磁盘访问而设计的数据结构（B树和B+树的结构类似于磁盘结构：盘面->磁道->扇区[每个扇区存储数据]），
    可以用于处理文件系统和数据库索引。
    B树的非叶节点也存储数据，B+树只在叶节点存储数据。B+树更类似磁盘结构。
    因为B树的数据本身还是链表，可以综合树和链表的特点实现比B树更快的查询（比如当查询连续或间隔较小的几个数据，
    第一个数据可以使用树的方式进行二分查找，后面几个数据直接使用链表查找）。
    
    参考《算法导论》第18章  
    国内教材说阶数m其实和最小度数是一个东西，最小度数要求键上限为2*t-1，那么它的子节点最多就是2*t, 即 m=2t 。
    
    ![B-Tree](../../../../../resources/images/b-tree.jpg)
    
    B树数据结构定义：  
    父节点引用  
    子节点引用链表  
    key链表  
    
    关键操作：  
    - 插入
    - 查找
    - 删除
    
    B树查找算法复杂度分析：  
    对于最小度数为t， 键数为n 的B树，求最差情况下（树高度最高为最差情况，高度决定磁盘IO的多少）时间算法复杂度。  
    《算法导论》已经给出了分析，如下：
    对于n, t一定要使8树最高，则
    第0层： 一个节点，1个键，两个子节点；
    第1层： 每个子节点有t-1个键，t个子节点；
    ...
    第h层：每个叶节点有t-1个键。
    则有 n >= 1 + 2*(t-1) + 2t*(t-1) + 2t^2*(t-1) + ... + 2t^(h-1)*(t-1)
    即 n>= 1 + 2(t-1)*[1+t+t^2+t^3+t^(h-1)] = 1+2(t-1)*(t^h-1)/(t-1) = 2t^h-1
    即 h <= logt[(n+1)/2]
    因为t << n,
    所以复杂度为 O(log(n/2)), 或者说O(log(n)) 。
    
    疑问：最小度数 t=3  
                   G M P T X  
    A B C D E | J K | N O | Q R S | U V | Y Z   
    这颗B树插入 L 键，为何不是  
                   G M P T X  
    A B C D E | J K L | N O | Q R S | U V | Y Z  
    而是  
                       P   
                G M    |     TX  
    A B C D E | J K L | N O | Q R S | U V | Y Z  
    根节点为5个键有什么问题么？为什么还要分裂一次？  
    书上说为了确保每次分裂节点的时候，父节点都不是满的，不然的话子节点分裂一次，父节点还需要继续分裂一次，
    导致代码无法写了（代码是递归实现的）
    
#### B+树
+ B+树定义
    ```
    一棵m阶的B+树和m阶的B树的差异在于：
    1.有n棵子树的结点中含有n 个关键字；
    2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B树的叶子节点并没有包括全部需要查找的信息)
    3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)
    ```
在数据库索引中使用，理解B+树对理解数据库索引很重要。  

![B-Tree](../../../../../resources/images/b+tree.png)

为什么说B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引？  
B+树的磁盘读写代价更低,B+树的非叶子结点并没有指向关键字具体信息的指针。
因此其非叶子结点相对B 树更小，如果把所有同一个非叶子结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，
树的高度相应降低，数的高度就对应I/O的次数，查找效率相应提高。因为树的高度决定了磁盘读写的次数，相对内存处理速度，
磁盘I/O是非常耗时的操作，是查找效率的主要因素，降低树的高度就等于提高查询效率。


#### 堆
+ 堆的定义：
    1）它是完全二叉树（除了最后一层节点不是满的，其他每一层从左到右都是满的）；
    2）堆树中某个节点的值总是不大于或不小于其孩子节点的值;
    3）堆树中每个节点的子树都是堆树。
    
    最大堆：父节点的键值总是大于或等于任何一个子节点的键值；  
    最小堆：父节点的键值总是小于或等于任何一个子节点的键值。  
    
    常用一个数组实现（为何使用数组而不是由引用连接起来的各个节点来存储二叉树？）
    注意： 父节点索引 pindex 与子节点索引 cindex 关系 : pindex = ceil(cindex/2)-1 如：索引为5的父节点对应两个索引分别为11,12的子节点。
    堆相比于二叉搜索树是弱序的。
    
+ 堆与数组对应关系
    ![heap_array](../../../../../resources/images/heapArray.png)
    
    堆的插入 insert() 算法 （数据结构(Java版) C12P438）  
    插入新元素后需要堆仍旧保持堆的特性，插入的时候总是先插入到最后，然后一级一级地与父节点比较，
    新节点大于父节点就交换位置，否则直接退出。
    
    堆的移除 remove() 算法
    总是移除堆顶，然后将最后一个子节点放在堆顶，然后再比较左右子节点，与较大的子节点交换位置，
    这样一级一级比下去。
    
    理解了父子节点的对应关系，以及insert remove操作原理，就很容易实现堆的数据结构。
    

    