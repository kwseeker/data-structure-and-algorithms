# 动态规划

动态规划是运筹学的一个分支。

**基本概念**：

+ 最优化原理

  将多阶段的过程问题求解转化为一系列单阶段问题求解，选择各阶段的决策使整个过程达到最优，这就是动态规划的基本思想。

+ 最优子结构

  最优策略序列的子策略序列总是最优的。

+ 重叠子结构

+ 动态规划求解的问题具有状态的无后效性

**动态规划的经典的案例**：

+ **最短路线**

+ **切杆问题**

+ **0-1背包问题**

  动态规划解决0-1背包问题举例：

  有5个物品，重量分别是{2,2,6,5,4}, 价值分别是{6,3,5,4,6}，背包容量为10，求装入背包的物品和获得的最大价值。

  设xi表示物品i装入背包，xi=0表示物品i没有被装入背包；

  约束条件：
  $$
  \left\{\begin{array}{c}\sum_{i=1}^n w_i x_i\leq C\\ x_i\in\{0,1\}\quad(1\leq i\leq n)\\ 
  \end{array}\right.
  $$
  即装入背包的物品总重量要不大于背包容量；

  目标函数：
  $$
  \max\quad\sum_{i=1}^n v_i x_i
  $$
  即放入背包的物品总价值。

  问题归结为寻找一个满足约条件式1,并使目标函数式2达到最大的解向量X={x1,x2,...,xn}。

  设V(i, j) 表示在前i(1<=i<=n)个物品中能够装入容量为（1<=j<=C）的背包中的物品最大价值，则可推导出动态规划函数：
  $$
  V(i,j)=\begin{cases}V(i-1,j)&j<w_i\\ \max\{V(i-1,j),&V(i-1,j-w_i)+v_i\}&j>=w_i\end{cases}
  $$

  $$
  V(i,0)=V(0,j)=0
  $$

  从自低向上法处理(这里选择从选择物品数最少占用容量最少开始)：

  |           | i\价值\j | 0    | 1    | 2    | 3    | 4    | 5    | 6     | 7     | 8     | 9    | 10   |
  | --------- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ----- | ---- | ---- |
  |           | 0        | 0    | 0    | 0    | 0    | 0    | 0    | 0     | 0     | 0     | 0    | 0    |
  | w1=2,v1=6 | 1        | 0    | 0    | 6<1> | 6    | 6    | 6    | 6     | 6     | 6     | 6    | 6    |
  | w2=2,v2=3 | 2        | 0    | 0    | 6<2> | 6    | 9<3> | 9    | 9     | 9     | 9     | 9    | 9    |
  | w3=6,v3=5 | 3        | 0    | 0    | 6    | 6    | 9    | 9    | 9     | 9     | 11    | 11   | 14   |
  | w4=5,v4=4 | 4        | 0    | 0    | 6    | 6    | 9    | 9    | 9     | 10<5> | 11    | 13   | 14   |
  | w5=4,v5=6 | 5        | 0    | 0    | 6    | 6    | 9    | 9    | 12<4> | 12    | 15<6> | 15   | 15   |

  通过函数4, (i=0,j) 和 (i, j=0) 的行和列都是0；

  通过函数3的j<wi的情况推出：V(i=1,j=1) = V(0,1) = 0, 进而推出 V(i,j=1)那列全为0；

  <1>: i=1,j=2, 满足j>=w1, V(1,2) = max{V(0,2), V{0, 2-w1} + v1} = 6

  <2>: i=2,j=2, 满足j>=w2, V(2,2) = max{V(1,2), V{1, 2-w2} + v2} = max{6, V{1,0} + 3} = max{6,3} = 6

  <3>:  i=2,j=4, 满足j>=w2, V(2,4) = max{V(1,4), V{1, 4-w2} + v2} = max{6, V{1,2} + 3} = max{6,9} = 9

  <4>:  i=5,j=6, 满足j>=w5, V(5,6) = max{V(4,6), V{4, 6-w5} + v5} = max{9, V{4,2} + 6} = max{9,12} = 12

  <5>:  i=4,j=7, 满足j>=w4, V(4,7) = max{V(3,7), V{3, 7-w4} + v4} = max{3, V{3,2} + 4} = max{6,10} = 10

  <6>:  i=5,j=8, 满足j>=w5, V(5,8) = max{V(4,8), V{4, 8-w5} + v5} = max{11, V{4,4} + 6} = max{11,15} = 15

  代码实现：

  ```java
  //二维数组，自底向上两层遍历，每个元素代入公式3,4进行求解最优子结构
  
  ```

  > 难点是抽象出约束条件、目标函数，然后准确推导出动态规划函数，有了函数其他就很简单了。

+ 最长公共子序列问题（LCS）

**动态规划实现**：

+ 递归法

+ 带备忘的自顶向下法

  优化的递归法

+ 自低向上法

  从更小的子问题开始求解，当求解某个子问题时，它所依赖的更小的子问题都已求解完毕，每个子问题只需要求解一次。

**求解步骤**：

1）找出最优解的性质，并刻画其结构特征；

2）递归的定义最优值；

3）以自底向上的方式计算出最优值；

4）根据计算最优值时记录的信息，构造最优解。

