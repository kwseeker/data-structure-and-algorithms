## 树
参考：    
《算法导论》  
《数据结构Java版》  
《数据结构与算法分析：java分析》
维基百科对计算机科学树的总结  https://en.wikipedia.org/wiki/Template:CS_trees  
                          https://zh.wikipedia.org/zh-hans/Template:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%AD%E7%9A%84%E6%A0%91  

相关术语：  
节点层次（根节点层次为1）  
树的深度（高度）  
节点的度（节点分支个数）  
无序树与有序树（树中任意一个结点的各子树按从左到右是有序的，称为有序树，否则称为无序树。）  

注意：树是图的一种。  

疑问：线段树和区间树到底是不是同一种数据结构？
看英文的资料说 segment tree, interval tree, range tree是三种不同的数据结构，但是中文网上的博客翻译的乱七八招的。

#### 基本分类
从网上抄的一个分类表，这个分类有问题，后面全部理清重新分类。

+ 二叉树（每个节点最多只有两个子节点） 
    - 完全二叉树（若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都必须达到最大个数，第h 层所有的结点都连续集中在最左边）
        * 满二叉树（一棵深度为k，且有2^k-1个节点的树是满二叉树）
    - 二叉排序树[二分搜索树] （左子树所有节点均小于根节点的值，右子树所有节点均大于根节点的值，左右子树也分别为二叉排序树）
    - 平衡二叉树（它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。）
        * 线段树[Segment Tree]（是一种平衡二叉搜索树）
        * AVL树 (经典的自平衡二叉排序树)
        * 红黑树（自平衡的二叉排序树）
            + 区间树 
    - 堆（一种完全二叉树，某个节点的值总是不大于或不小于其孩子节点的值，堆的每个子树也是堆）
+ 霍夫曼树
+ B树
    - B树（B-树）
    - B+树
    - B*树
    - 2-3树
    - 2-3-4树
+ 键树
+ 字典树[Trie]（又称前缀树，是专门为字符串设计的一种数据结构，其查询时间复杂度只与字符串的长度相关O(w), w为查询单词的长度）
+ 后缀树
+ 败者数与胜者树

#### 二叉排序树/二分搜索树（BST, Binary Search Tree）

定义：  
左子树所有节点均小于根节点的值，右子树所有节点均大于根节点的值，左右子树也分别为二叉排序树。

根据遍历时根节点的顺序分为前序遍历、中序遍历、后序遍历；  
前序遍历（根节点->左子节点->右子节点）  
中序遍历（左子节点->根子节点->右子节点）  
后序遍历（左子节点->右子节点->根子节点）  
层序遍历（又成为广度遍历，从顶向下一层一层的遍历，使用队列实现）

#### AVL树

##### 基本概念  
平衡因子：针对某个节点而言，若以此节点为根节点，左子树的高度减去右子树的高度，即为平衡因子，平衡二叉树的平衡因子为-1/0/+1。  

##### 定义（自己定义的）
在二叉排序树基础上添加某些平衡机制，使其同时满足平衡二叉树的特点，而生成的树。

##### AVL树的自平衡机制  

插入节点作为不平衡节点的左孩子的左孩子（LL），以及RR, 只需要右旋转或者左旋转即可。
如果插入节点作为不平衡节点的左孩子的右孩子（LR）, 则先将不平衡节点的左子树左旋转，然后再整体右旋转；对于RL，现将不平衡节点的右子树右旋转再整体左旋转。

左旋转和右旋转

    LL和RR:
           y                   y 
          / \                 / \
         x   T4              T4  x
        / \                     / \
       z   T3                  T3  z
      / \                         / \
     T1 T2                       T1 T2
  
    不平衡的二叉排序树都可以抽象为上面的两种结构, 左右旋转只是个操作的名字，
    如何保持平衡，想想应该也知道了。
  
         x
       /   \
      z     y
     /\     /\
    T1 T2  T3 T4
    
    LR和RL:
           y                   y 
          / \                 / \
         x   T4              T4  x
        / \                     / \
       T3  z                   z   T3
          / \                 / \
         T1 T2               T1 T2
    
    
##### AVL树的核心方法实现  

比较麻烦的方法主要是插入和删除节点，因为会影响树的平衡性。其他方法
和BST一样，实现比较简单。

AVL树的数据插入： 数据插入过程是在BST插入过程基础上，又添加了平衡性判断以及维护平衡的操作；   
    1) 判断插入的数据键与左右子树的大小，递归插入到树中；
    2）同样通过递归更新每个节点的高度计算平衡因子，当平衡因子绝对值大于等于2，
    判断当前属于哪一种非平衡模型LL,RR,LR,RL;针对每种情况分别执行平衡措施；
    3）因为方法本身是递归方法，可以逐级从底到顶维护自平衡。
AVL树的数据删除： 在BST删除的基础上添加平衡性判断和操作。
    1) （递归）选择被删除节点的前驱或者后继替代被删除节点的位置；
    2）递归的每一层都更新节点高度并计算平衡因子，然后执行和插入同样的平衡操作。

#### 红黑树
    

#### 线段树

TODO: 不知下面的定义是否准确，网上的文章都是各种误导，各种和区间树的混为一谈。

线段树（存储区间） https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%AE%B5%E6%A8%B9_(%E5%84%B2%E5%AD%98%E5%8D%80%E9%96%93)

线段树的定义：  
线段树是一种平衡二叉排序树，  
对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。  
因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。  

应用场景： 某些只关注区间的场景；  
如：实际应用中经常遇到区间查询场景，如电商查询某类产品在某个价格区间的产品列表；
如：区间染色的问题（对区间某个子区间进行染色，经过m次操作之后，可以在[i, j]区间看到多少种颜色？）。

上面的问题可以也可以使用数组解决，但是线段树的算法复杂度更低。

操作 | 数组实现 | 线段树实现 
---|---|--- 
更新 | O(n) | O(logn) 
查询 | O(n) | O(logn)

#### B树
+ B树定义
    B树和B+树是为了处理磁盘访问而设计的数据结构（B树和B+树的结构类似于磁盘结构：盘面->磁道->扇区[每个扇区存储数据]），
    可以用于处理文件系统和数据库索引。
    B树的非叶节点也存储数据，B+树只在叶节点存储数据。B+树更类似磁盘结构。
    因为B树的数据本身还是链表，可以综合树和链表的特点实现比B树更快的查询（比如当查询连续或间隔较小的几个数据，
    第一个数据可以使用树的方式进行二分查找，后面几个数据直接使用链表查找）。
    
    参考《算法导论》第18章  
    国内教材说阶数m其实和最小度数是一个东西，最小度数要求键上限为2*t-1，那么它的子节点最多就是2*t, 即 m=2t 。
    
    ![B-Tree](../../../../../resources/images/b-tree.jpg)
    
    B树数据结构定义：  
    父节点引用  
    子节点引用链表  
    key链表  
    
    关键操作：  
    - 插入
    - 查找
    - 删除
    
    B树查找算法复杂度分析：  
    对于最小度数为t， 键数为n 的B树，求最差情况下（树高度最高为最差情况，高度决定磁盘IO的多少）时间算法复杂度。  
    《算法导论》已经给出了分析，如下：
    对于n, t一定要使8树最高，则
    第0层： 一个节点，1个键，两个子节点；
    第1层： 每个子节点有t-1个键，t个子节点；
    ...
    第h层：每个叶节点有t-1个键。
    则有 n >= 1 + 2*(t-1) + 2t*(t-1) + 2t^2*(t-1) + ... + 2t^(h-1)*(t-1)
    即 n>= 1 + 2(t-1)*[1+t+t^2+t^3+t^(h-1)] = 1+2(t-1)*(t^h-1)/(t-1) = 2t^h-1
    即 h <= logt[(n+1)/2]
    因为t << n,
    所以复杂度为 O(log(n/2)), 或者说O(log(n)) 。
    
    疑问：最小度数 t=3  
                   G M P T X  
    A B C D E | J K | N O | Q R S | U V | Y Z   
    这颗B树插入 L 键，为何不是  
                   G M P T X  
    A B C D E | J K L | N O | Q R S | U V | Y Z  
    而是  
                       P   
                G M    |     TX  
    A B C D E | J K L | N O | Q R S | U V | Y Z  
    根节点为5个键有什么问题么？为什么还要分裂一次？  
    书上说为了确保每次分裂节点的时候，父节点都不是满的，不然的话子节点分裂一次，父节点还需要继续分裂一次，
    导致代码无法写了（代码是递归实现的）
    
#### B+树
+ B+树定义
    ```
    一棵m阶的B+树和m阶的B树的差异在于：
    1.有n棵子树的结点中含有n 个关键字；
    2.所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B树的叶子节点并没有包括全部需要查找的信息)
    3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)
    ```
在数据库索引中使用，理解B+树对理解数据库索引很重要。  

![B-Tree](../../../../../resources/images/b+tree.png)

为什么说B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引？  
B+树的磁盘读写代价更低,B+树的非叶子结点并没有指向关键字具体信息的指针。
因此其非叶子结点相对B 树更小，如果把所有同一个非叶子结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，
树的高度相应降低，数的高度就对应I/O的次数，查找效率相应提高。因为树的高度决定了磁盘读写的次数，相对内存处理速度，
磁盘I/O是非常耗时的操作，是查找效率的主要因素，降低树的高度就等于提高查询效率。


#### 堆  
+ 堆的定义：  
    1）它是完全二叉树（除了最后一层节点不是满的，其他每一层从左到右都是满的）；  
    2）堆树中某个节点的值总是不大于或不小于其孩子节点的值;  
    3）堆树中每个节点的子树都是堆树。  
    
    最大堆：父节点的键值总是大于或等于任何一个子节点的键值；    
    最小堆：父节点的键值总是小于或等于任何一个子节点的键值。  
    
    常用一个数组实现（为何使用数组而不是由引用连接起来的各个节点来存储二叉树？）  
    注意： 父节点索引 pindex 与子节点索引 cindex 关系 : pindex = ceil(cindex/2)-1 如：索引为5的父节点对应两个索引分别为11,12的子节点。
    堆相比于二叉搜索树是弱序的。  
    
+ 堆与数组对应关系
    ![heap_array](../../../../../resources/images/heapArray.png)
    
    堆的插入 insert() 算法 （数据结构(Java版) C12P438）  
    插入新元素后需要堆仍旧保持堆的特性，插入的时候总是先插入到最后，然后一级一级地与父节点比较，
    新节点大于父节点就交换位置，否则直接退出。
    
    堆的移除 remove() 算法
    总是移除堆顶，然后将最后一个子节点放在堆顶，然后再比较左右子节点，与较大的子节点交换位置，
    这样一级一级比下去。
    
    理解了父子节点的对应关系，以及insert remove操作原理，就很容易实现堆的数据结构。
    
#### 字典树【Trie】

字典树是一种多叉树，将每一个字符作为一个节点，垂直方向上的字符组成应用中的一个字符串。  

字典树的结构  
![Trie](../../../../../resources/images/trie.png)  

```
//常规的字典树的节点的定义
class Node{
    char c;
    Node next[26];  //使用数组存储子节点，同样可以使用链表、Set、树存储。
}

//这里使用TreeMap替换数组存储子节点。
//使用TreeMap存储每一层字符。root.next是TreeMap实例存储第一层字符(如：c d b), 然后每个TreeMap节点的next引用又是一个TreeMap实例，
//存储第一层每个字符下的第二层字符，后面同理。
class Node {
    boolean isWord;         //表示是否为单词结尾
    Map<char, Node> next;   
}
```

核心方法  
添加单词：依次从字符串中取出字符，从根节点开始判断字符是否存在，不存在则循环创建后续节点，存在则继续判断下一个字符在前一个字符节点下是否存在。
查询单词：依次从字符串取出字符，从根节点开始判断字符是否存在，不存在退出返回false,否则在子节点递归查后面的字符。
前缀查询节点：同上基本类似。
模式匹配：同上类似。
删除单词：递归删除，判断最后一个字符是否isWord为true, 然后判断节点是否无其他分支，无其他分支删除此节点，有其他分支直接isWord设置为false,
        递归倒数第二个节点，是否还有其他分支，无其他分支则删除节点继续递归，否则退出；

