# 回溯法

## 基本原理

是一种发现所有或部分解的一种通用策略。

**思想**：逐步构建部分备选解；如果备选解不能成为一个有效的解，则立即放弃该分支。

将所有的解（问题的解空间）按照一定结构排列，再进行搜索。

回溯法相对于蛮力法用排除法减少了搜索空间。

回溯法代码表示形式就是一颗树(常用递归实现，如果递归次数超过栈深限制，改用树实现)。

**回溯法经典的案例**：

+ 求可行解问题
  + 八皇后问题
  + 子集和问题
  + 地图填色问题
+ 求最优解问题
  + 0-1背包问题

**基本概念**：

+ 解空间

  解空间是所有解向量的组合，以4皇后问题为例，解向量表示为x=(x1,x2,x3,x4)， xi表示第i行或第i列皇后所在位置，xi的取值范围是si = {1,2,3,4}。

+ 可能解

+ 可行解

  满足约束条件的解空间中的一个子集。

+ 最优解

  使目标函数取极值（极大或极小）的可行解，一个或少数几个。

+ 约束
  + 显约束
  + 隐约束（推导出的约束）

> 找可行解，一般找到就停止；找最优解一般要遍历整棵树。

**实现**：顺序选择构建状态空间树（state space tree）

1）从根节点开始记录一次所有可能选择的中间节点，然后按照固定顺序，选择其中一个节点（深度优先搜索DFS）；

2）将选择的节点作为“根节点”，继续上面步骤，如果没有可选的节点则返回上一节点，按顺序选择同层下一节点，作为“根节点”继续上面步骤；

3）直到最终找到满足条件的可行解。

回溯代码模板：

```java
void backtrack(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

难点：

+ 挖掘完整的约束条件并准确地用代码表述
+ 存储递归过程中的临时数据（递归完成要及时清理临时数据）



## 算法示例

### **LeeCode回溯法题目**:

#### 组合问题

+ 77.组合
+ 216.组合总和III
+ 17.电话号码的字母组合
+ 39.组合总和
+ 40.组合总和II

#### 分割问题

+ 131.分割回文串
+ 93.复原IP地址

#### 子集问题

+ 78.子集
+ 90.子集II

#### 排列问题

+ 46.全排列
+ 47.全排列II

#### 棋盘问题

+ 51.N皇后

  答案：NQueens.java、NQueens1.java、NQueens2.java

+ 37.解数独

  答案：Sudoku.java

#### 其他

+ 491.递增子序列
+ 332.重新安排行程